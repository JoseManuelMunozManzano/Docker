39. Multi-stage build
---------------------
  Imaginemos este escenario en un fichero Dockerfile. Tenemos los siguientes bloques que están todos juntos:
    - Comandos para instalar las dependencias
    - Ejecutar test
    - Hacer el build
    - Ejecutar la aplicación
  
  Tal y como hemos estado haciendo el fichero Dockerfile, si un pequeño cambio sucede en la parte de instalar 
  las dependencias, todo lo que sigue después de ese cambio se va a tener que volver a reconstruir, evaluar y
  ejecutar aunque esas otras partes no han cambiado nada.

  La idea del multi-stage es tomar los bloques anteriores y crear pequeñas imágenes temporales que se encargan 
  de una sola tarea y cuyo objetivo final es construir la imagen que nosotros queremos.
  En concreto, podemos tener las siguientes etapas:
    - Stage con todas las dependencias (en nuestra app solo package.json)
    - Stage con el testing y el build (suelen estar juntos porque si cambia el código tenemos que hacer el
      testing y el build)
    - Stage para ejecutar las dependencias de producción
    - Stage para construir propiamente la imagen de nuestra aplicación

  Estas imágenes temporales pueden compartir información, porque son independientes entre si y completamente
  aisladas.
  Por ejemplo, al instalar las dependencias de los paquetes de Node en el primer stage, tendremos que moverlos
  al stage siguiente de testing y build.
  El objetivo del build es crear la carpeta dist con nuestro código fuente. Pues esa carpeta dist la pasaremos
  al stage siguiente de ejecución de dependencias de Pro.

  Y al final, solo exportamos la última imagen, con lo que el tamaño será menor.

  De esta forma, la parte que no cambia no tiene que hacer absolutamente nada, ya estén en cache y se reutilizan.

40. Proyecto
------------
  Vamos a seguir el proyecto en la carpeta: 09-cron-ticker-multi-stage

41. Multi-State Build (o Multi-Stage Build)
-------------------------------------------
  - Documentación:
      https://phoenixnap.com/kb/docker-add-vs-copy
      https://docs.docker.com/engine/reference/builder/#copy

    Se aconseja más trabajar con COPY para evitar efectos secundarios.

  - Nuestro primer stage instala dependencias y va a ser conocido como deps.
    Fichero Dockerfile queda así:

FROM node:19.2-alpine3.16 as deps
WORKDIR /app
COPY package.json ./
RUN npm install

  - Nuestra segundo stage va a testear y construir la app y lo vamos a llamar builder
    Si el testing falla ya no sigue con los siguientes stages.
    Debajo de lo anterior, en nuestro fichero Dockerfile, añadimos:

FROM node:19.2-alpine3.16 as builder
WORKDIR /app
# Copiamos del stage deps los node_modules al stage builder en la carpeta ./node_modules
COPY --from=deps /app/node_modules ./node_modules
# Dest /app
COPY . .
# Realizar testing
RUN npm run test
# Aquí haríamos para construir la app optimizada para producción:
# RUN npm run build
# Pero no hace falta porque en nuestra app no tenemos ese script.

  - El tercer stage crear las dependencias de producción.
    Debajo de lo anterior, en nuestro fichero Dockerfile, añadimos:

FROM node:19.2-alpine3.16 as prod-deps
WORKDIR /app
COPY package.json ./
RUN npm install --prod

  - El cuarto stage ejecuta la aplicación y lo llamaremos runner
    Debajo de lo anterior, en nuestro fichero Dockerfile, añadimos:

FROM node:19.2-alpine3.16 as runner
WORKDIR /app
COPY --from=prod-deps /app/node_modules ./node_modules
# Copiar los fuentes que necesito
# Si tuviese una carpeta dist con los fuentes ya optimizados, copiaría solo ese directorio.
COPY app.js ./
COPY tasks ./tasks
# Ejecutar comandos cuando se inicia un contenedor
CMD [ "node", "app.js" ]

  - Creamos la imagen usando nuestro fichero Dockerfile
      docker build --tag neimerc/cron-ticker:perro .

  - Y el latest
      docker build --tag neimerc/cron-ticker:latest .

  - Montamos el contenedor y vemos si funciona.
      docker container run neimerc/cron-ticker

  - Subir imagenes
      docker push neimerc/cron-ticker:perro
      docker push neimerc/cron-ticker:perro

42. Build con otras arquitecturas
---------------------------------
  De nuevo vamos a usar buildx para construir nuestra imagen en varias arquitecturas.
  Para más documentación ver 00 - 03 - Dockerfile.txt, puntos 37 y 38.

  - Ver los builders disponibles.
      docker buildx ls

  - Crear un nuevo buildx
      docker buildx create --name mybuilder --driver docker-container --bootstrap

  - Para cambiar al buildx que hemos creado:
      docker buildx use mybuilder

  - Crear la imagen en las distintas plataformas
      docker buildx build --platform linux/amd64,linux/arm64 -t neimerc/cron-ticker:gato --push .

  - Inspeccionar la imagen para ver las diferentes plataformas creadas
      docker buildx imagetools inspect neimerc/cron-ticker:gato
  
  - No olvidar el latest
      docker buildx build --platform linux/amd64,linux/arm64 -t neimerc/cron-ticker --push .

  - Eliminar el builder. Tenemos que cambiar a otro builder y luego borrarlo.
      docker buildx use desktop-linux
      docker buildx rm mybuilder

43. Nuevo Proyecto
------------------
  Vamos a seguir el proyecto de la carpeta: 10-teslo-shop

  - En el punto en el que está solo hay que levantarlo de la siguiente manera (ver README.md)
      docker compose up -d
      yarn start:dev

  - Ejecutar el seed
      http://localhost:3000/api/seed
  
  - Ver la información en Swagger
      http://localhost:3000/api
  
  - Para terminar echar abajo el docker compose
      docker compose down

44. Docker compose - Target State
---------------------------------
  Vamos a mezclar el docker compose con el build del Dockerfile.

